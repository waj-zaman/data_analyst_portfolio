"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PromiseQueue_1 = require("./Utils/PromiseQueue");
class WebComponentManager {
    static authRequired(src, forceTokenSync) {
        if (!forceTokenSync) {
            return true;
        }
        try {
            const url = new URL(src);
            if (this.signedInOrigins.has(url.origin)) {
                return false;
            }
        }
        catch (_a) {
            // we reach here if url is invalid but we cannot do much here. Jut continue the normal flow.
            return true;
        }
        return true;
    }
    static updateSignedInOrigin(src, forceTokenSync) {
        if (!forceTokenSync) {
            return;
        }
        try {
            const url = new URL(src);
            this.signedInOrigins.add(url.origin);
        }
        catch (e) {
            // not a lot we can do here
            return;
        }
    }
    static clearOrigin(src, forceTokenSync) {
        if (!forceTokenSync) {
            return;
        }
        if (!src) {
            return;
        }
        try {
            const url = new URL(src);
            this.signedInOrigins.delete(url.origin);
        }
        catch (e) {
            //not a lot we can do here
            return;
        }
    }
    static registerWebComponent(webComponent) {
        const assignedId = this.embeddingIndex;
        this.webComponents.set(assignedId, webComponent);
        this.embeddingIndex++;
        return assignedId;
    }
    static unregisterWebComponent(embeddingIndex) {
        this.webComponents.delete(embeddingIndex);
    }
    // Methods below only used for testing
    static getWebComponents() {
        const webComponentsCloned = new Map();
        // a shallow copy is good enough
        this.webComponents.forEach((webComponent, embeddingIndex) => {
            webComponentsCloned.set(embeddingIndex, webComponent);
        });
        return webComponentsCloned;
    }
    static synchronizeRender(func) {
        const promise = this.queue.add(func);
        this.queue.poll();
        return promise;
    }
    static clear() {
        this.webComponents.clear();
    }
}
exports.WebComponentManager = WebComponentManager;
// This contains a static counter & a map that keeps track of the webComponents embedded.
WebComponentManager.embeddingIndex = 0;
WebComponentManager.webComponents = new Map();
WebComponentManager.queue = new PromiseQueue_1.PromiseQueue();
WebComponentManager.signedInOrigins = new Set();
//# sourceMappingURL=WebComponentManager.js.map