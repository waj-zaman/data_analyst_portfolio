"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const Contract = __importStar(require("@tableau/api-external-contract-js"));
const Enums_1 = require("@tableau/api-external-contract-js/lib/src/ExternalContract/Embedding/Enums");
const api_internal_contract_js_1 = require("@tableau/api-internal-contract-js");
const api_shared_js_1 = require("@tableau/api-shared-js");
const TableauWebComponent_1 = require("../Components/TableauWebComponent");
const FirstVizSizeKnownEvent_1 = require("../Events/FirstVizSizeKnownEvent");
const TabSwitchedEvent_1 = require("../Events/TabSwitchedEvent");
const ToolbarStateChangedEvent_1 = require("../Events/ToolbarStateChangedEvent");
const EmbeddingWorkbookImpl_1 = require("../Impl/EmbeddingWorkbookImpl");
const CustomView_1 = require("../Models/CustomView");
const VizSize_1 = require("../Models/VizSize");
const Services_1 = require("../Services");
const RegisterAllEmbeddingServices_1 = require("../Services/RegisterAllEmbeddingServices");
const HtmlElementHelpers_1 = require("../Utils/HtmlElementHelpers");
class VizImpl {
    constructor(_viz, _iframe, _frameUrl, _embeddingId) {
        this._viz = _viz;
        this._iframe = _iframe;
        this._frameUrl = _frameUrl;
        this._embeddingId = _embeddingId;
        this._automaticUpdatesArePaused = false;
        this._resizeEventType = 'resize';
        if (!this._iframe) {
            throw new api_shared_js_1.TableauError(Contract.EmbeddingErrorCodes.InternalError, 'Iframe has not been created yet');
        }
    }
    get workbookImpl() {
        return this._workbookImpl;
    }
    get iframe() {
        return this._iframe;
    }
    get embeddingId() {
        return this._embeddingId;
    }
    get exportScenariosForPdfAndPowerPoint() {
        return {
            currentSheetName: this._workbookImpl.activeSheet.name,
            exportableSheetNamesFromDashboard: this.exportableSheetNamesFromDashboard,
            exportableSheetNamesFromWorkbook: this.exportableSheetNamesFromWorkbook,
        };
    }
    get exportableSheetNamesFromDashboard() {
        const currentSheet = this._workbookImpl.activeSheet;
        if (currentSheet && currentSheet.sheetType === Contract.SheetType.Dashboard) {
            return currentSheet.getWorksheetNamesFromZones();
        }
        return [];
    }
    get exportableSheetNamesFromWorkbook() {
        const exportableSheetNames = [];
        if (this._workbookImpl) {
            for (const publishedSheetInfo of this._workbookImpl.publishedSheetsInfo) {
                exportableSheetNames.push(publishedSheetInfo.name);
            }
        }
        return exportableSheetNames;
    }
    get automaticUpdatesArePaused() {
        return this._automaticUpdatesArePaused;
    }
    // TODO: TFS 892510 TabSwitchEvent etc is resposible for updating the state
    set automaticUpdatesArePaused(isAutoUpdate) {
        this._automaticUpdatesArePaused = isAutoUpdate;
    }
    getVisualIdForSheetName(sheetName) {
        var _a, _b, _c;
        const currentSheet = this._workbookImpl.activeSheet;
        switch (currentSheet.sheetType) {
            case Contract.SheetType.Worksheet:
                if (currentSheet.name === sheetName) {
                    return currentSheet.visualId;
                }
                break;
            case Contract.SheetType.Dashboard: {
                const dashboardImpl = currentSheet;
                for (const worksheetName of dashboardImpl.getWorksheetNamesFromZones()) {
                    if (worksheetName === sheetName) {
                        return { worksheet: worksheetName, dashboard: dashboardImpl.name };
                    }
                }
                break;
            }
            case Contract.SheetType.Story: {
                const storyImpl = currentSheet;
                const containedSheet = (_a = storyImpl.activeStoryPoint) === null || _a === void 0 ? void 0 : _a.containedSheet;
                if (containedSheet && containedSheet.sheetType === Contract.SheetType.Worksheet && containedSheet.name === sheetName) {
                    // TFSID 1505602: VisualId is incomplete for worksheets within stories
                    const visualId = Object.assign({}, containedSheet.visualId);
                    visualId.dashboard = visualId.worksheet;
                    visualId.storyboard = storyImpl.name;
                    visualId.storyPointID = (_b = storyImpl.activeStoryPoint) === null || _b === void 0 ? void 0 : _b.storyPointId;
                    return visualId;
                }
                else if (containedSheet && containedSheet.sheetType === Contract.SheetType.Dashboard) {
                    const dashboard = containedSheet;
                    // @W-12986439: use worksheetImpls here, but the VisualIds are still incomplete for worksheets within dashboards within stories (TFSID 1505602)
                    for (const worksheetName of dashboard.getWorksheetNamesFromZones()) {
                        if (worksheetName === sheetName) {
                            return {
                                worksheet: worksheetName,
                                dashboard: dashboard.name,
                                storyboard: storyImpl.name,
                                storyPointID: (_c = storyImpl.activeStoryPoint) === null || _c === void 0 ? void 0 : _c.storyPointId,
                            };
                        }
                    }
                }
                break;
            }
            default:
                throw new api_shared_js_1.TableauError(Contract.SharedErrorCodes.ServerError, 'Invalid SheetType');
        }
        throw new api_shared_js_1.TableauError(Contract.SharedErrorCodes.InvalidParameter, 'sheetName parameter must belong to a worksheet within the current view');
    }
    get exportableWorksheetNames() {
        var _a;
        const currentSheet = this._workbookImpl.activeSheet;
        switch (currentSheet.sheetType) {
            case Contract.SheetType.Worksheet:
                return [currentSheet.name];
            case Contract.SheetType.Dashboard:
                return currentSheet.getWorksheetNamesFromZones();
            case Contract.SheetType.Story: {
                const containedSheet = (_a = currentSheet.activeStoryPoint) === null || _a === void 0 ? void 0 : _a.containedSheet;
                if (containedSheet && containedSheet.sheetType === Contract.SheetType.Worksheet) {
                    return [containedSheet.name];
                }
                else if (containedSheet && containedSheet.sheetType === Contract.SheetType.Dashboard) {
                    return containedSheet.getWorksheetNamesFromZones();
                }
                break;
            }
            default:
                break;
        }
        return [];
    }
    initializeViz() {
        const iframeWindow = this._iframe.contentWindow;
        if (!iframeWindow) {
            throw new api_shared_js_1.TableauError(Contract.EmbeddingErrorCodes.InternalError, 'Iframe has not been created yet');
        }
        try {
            this._messenger = new api_internal_contract_js_1.CrossFrameMessenger(window, iframeWindow, this._frameUrl.origin);
            // We need the notification service for the bootstrap flow.
            this._dispatcher = new api_shared_js_1.CrossFrameDispatcher(this._messenger);
            Services_1.registerInitializationEmbeddingServices(this._dispatcher, this.embeddingId);
            RegisterAllEmbeddingServices_1.registerAuthServices(this._dispatcher, this.embeddingId);
            const initializationService = api_shared_js_1.ApiServiceRegistry.get(this.embeddingId).getService("initialization-service" /* Initialization */);
            const vizSizeKnownUnregister = initializationService.registerHandler(api_internal_contract_js_1.NotificationId.FirstVizSizeKnown, () => true, (model) => {
                this.handleVizSizeKnownEvent(model);
                vizSizeKnownUnregister();
            });
            const vizInteractiveUnregister = initializationService.registerHandler(api_internal_contract_js_1.NotificationId.VizInteractive, () => true, (model) => {
                this.handleVizInteractiveEvent(model);
                vizInteractiveUnregister();
            });
            initializationService.registerHandler(api_internal_contract_js_1.NotificationId.ReadyToReceiveAuthToken, () => true, () => {
                this._viz.dispatchEvent(new CustomEvent(Contract.EmbeddingTableauEventType.ReadyToReceiveAuthToken, {}));
            });
            initializationService.registerHandler(api_internal_contract_js_1.NotificationId.ToolbarStateChanged, () => true, (model) => this.handleToolbarStateEvent(model));
            initializationService.registerHandler(api_internal_contract_js_1.NotificationId.TabSwitched, () => true, (model) => this.handleTabSwitch(model));
            initializationService.registerHandler(api_internal_contract_js_1.NotificationId.CustomViewsLoaded, () => true, (model) => this.handleCustomViews(model));
            initializationService.registerHandler(api_internal_contract_js_1.NotificationId.CustomViewRemoved, () => true, (model) => this.handleCustomViewRemoved(model));
            initializationService.registerHandler(api_internal_contract_js_1.NotificationId.CustomViewSaved, () => true, (model) => this.handleCustomViewSaved(model));
            initializationService.registerHandler(api_internal_contract_js_1.NotificationId.CustomViewSetDefault, () => true, (model) => this.handleCustomViewSetDefault(model));
            this._messenger.startListening();
        }
        catch (e) {
            throw new api_shared_js_1.TableauError(Contract.EmbeddingErrorCodes.InternalError, 'Unexpected error during initialization.');
        }
    }
    dispose() {
        if (this._messenger) {
            this._messenger.stopListening();
        }
        this.removeWindowResizeHandler();
    }
    getCurrentSrcAsync() {
        const service = api_shared_js_1.ApiServiceRegistry.get(this.embeddingId).getService("viz-service" /* Viz */);
        return service.getCurrentSrcAsync();
    }
    revertAllAsync() {
        const service = api_shared_js_1.ApiServiceRegistry.get(this.embeddingId).getService("ToolbarService" /* ToolbarService */);
        return service.revertAllAsync();
    }
    redoAsync() {
        const service = api_shared_js_1.ApiServiceRegistry.get(this.embeddingId).getService("ToolbarService" /* ToolbarService */);
        return service.redoAsync();
    }
    undoAsync() {
        const service = api_shared_js_1.ApiServiceRegistry.get(this.embeddingId).getService("ToolbarService" /* ToolbarService */);
        return service.undoAsync();
    }
    refreshDataAsync() {
        const service = api_shared_js_1.ApiServiceRegistry.get(this.embeddingId).getService("data-source-service" /* DataSourceService */);
        return service.refreshAsync();
    }
    pauseAutomaticUpdatesAsync() {
        if (this._automaticUpdatesArePaused) {
            return Promise.resolve();
        }
        return this.setAutoUpdateAsync(false);
    }
    resumeAutomaticUpdatesAsync() {
        if (!this._automaticUpdatesArePaused) {
            return Promise.resolve();
        }
        return this.setAutoUpdateAsync(true);
    }
    toggleAutomaticUpdatesAsync() {
        return this.setAutoUpdateAsync(this._automaticUpdatesArePaused);
    }
    exportImageAsync() {
        const service = api_shared_js_1.ApiServiceRegistry.get(this.embeddingId).getService("ToolbarService" /* ToolbarService */);
        return service.exportImageAsync();
    }
    exportCrosstabAsync(sheetName, format) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = api_shared_js_1.ApiServiceRegistry.get(this.embeddingId).getService("export-service" /* Export */);
            yield service.exportCrosstabAsync(sheetName, format, this.exportableWorksheetNames, this._workbookImpl.activeSheet.sheetType);
        });
    }
    exportDataAsync(sheetName, options = api_shared_js_1.ExportHelpers.DefaultDataOptions) {
        const service = api_shared_js_1.ApiServiceRegistry.get(this.embeddingId).getService("export-service" /* Export */);
        return service.exportDataAsync(this.getVisualIdForSheetName(sheetName), options);
    }
    exportPowerPointAsync(sheetNames = []) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = api_shared_js_1.ApiServiceRegistry.get(this.embeddingId).getService("export-service" /* Export */);
            const exportScenarios = this.exportScenariosForPdfAndPowerPoint;
            if (sheetNames.length === 0) {
                sheetNames.push(exportScenarios.currentSheetName);
            }
            yield service.exportPowerPointAsync(sheetNames, exportScenarios);
        });
    }
    exportPDFAsync(sheetNames = [], options = api_shared_js_1.ExportHelpers.DefaultPDFOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = api_shared_js_1.ApiServiceRegistry.get(this.embeddingId).getService("export-service" /* Export */);
            const exportScenarios = this.exportScenariosForPdfAndPowerPoint;
            if (sheetNames.length === 0) {
                sheetNames.push(exportScenarios.currentSheetName);
            }
            yield service.exportPDFAsync(sheetNames, options, exportScenarios);
        });
    }
    displayDialogAsync(dialogType) {
        const service = api_shared_js_1.ApiServiceRegistry.get(this.embeddingId).getService("ToolbarService" /* ToolbarService */);
        switch (dialogType) {
            case Enums_1.TableauDialogType.ExportWorkbook:
                if (!this.workbookImpl.canDownloadWorkbook) {
                    throw new api_shared_js_1.TableauError(Contract.EmbeddingErrorCodes.DownloadWorkbookNotAllowed, 'Download workbook is not allowed');
                }
                return service.displayDownloadWorkbookDialogAsync();
            case Enums_1.TableauDialogType.ExportPDF:
                return service.displayExportPdfDialogAsync();
            case Enums_1.TableauDialogType.ExportPowerPoint:
                return service.displayExportPowerpointDialogAsync();
            case Enums_1.TableauDialogType.ExportData:
                return service.displayExportDataDialogAsync();
            case Enums_1.TableauDialogType.ExportCrossTab:
                return service.displayExportCrosstabDialogAsync();
            case Enums_1.TableauDialogType.Share:
                return service.displayShareDialogAsync();
            default:
                throw new api_shared_js_1.TableauError(Contract.EmbeddingErrorCodes.UnknownDialogType, 'Unknown dialog type');
        }
    }
    setAuthToken(token) {
        const service = api_shared_js_1.ApiServiceRegistry.get(this.embeddingId).getService("authentication" /* Authentication */);
        service.setAuthToken(token);
    }
    setAutoUpdateAsync(state) {
        const service = api_shared_js_1.ApiServiceRegistry.get(this.embeddingId).getService("ToolbarService" /* ToolbarService */);
        return service.setAutoUpdateAsync(state).then(() => {
            this._automaticUpdatesArePaused = !state;
            return;
        });
    }
    isVersionCompatible(platformVersion) {
        // Platform version will be undefined in 2021.4.
        // Return false when loading a 3.1+ library against 2021.4.
        if (!platformVersion) {
            return false;
        }
        // If our platform is less than the external library version, return false
        return api_internal_contract_js_1.VersionLessThan(api_internal_contract_js_1.INTERNAL_CONTRACT_VERSION, platformVersion) || api_internal_contract_js_1.VersionEqualTo(api_internal_contract_js_1.INTERNAL_CONTRACT_VERSION, platformVersion);
    }
    updateIframeTitle(bootstrapInfo) {
        this._iframe.setAttribute('title', TableauWebComponent_1.getLocalizedTitle(navigator.language) + ': ' + bootstrapInfo.workbookName + ': ' + bootstrapInfo.currWorksheetName);
    }
    handleVizInteractiveEvent(bootstrapInfo) {
        // Embedding API will currently block all api calls/notifications if there is an incompatible version.
        if (!this._viz.disableVersionCheck && !this.isVersionCompatible(bootstrapInfo.platformVersion)) {
            this._messenger.stopListening();
            throw new api_shared_js_1.TableauError(Contract.EmbeddingErrorCodes.IncompatibleVersionError, 'The version of the Embedding library is not compatible with the version of Tableau.' +
                ' The visualization will load, but the Embedding API methods and events are not available.');
        }
        // Update the iframe title so that screen reader users could distinguish between different vizzes embedded on the same page
        this.updateIframeTitle(bootstrapInfo);
        api_shared_js_1.registerAllSharedServices(this._dispatcher, this.embeddingId);
        Services_1.registerAllEmbeddingServices(this._dispatcher, this.embeddingId);
        this._viz.initializeEvents();
        // These are the steps involved. It's critical that this is in order
        // 1. Create the workbook
        // 2. Process Custom Views
        // 3. Send FirstInteractive event
        // 4. Send CustomViewLoaded event
        this._workbookImpl = new EmbeddingWorkbookImpl_1.EmbeddingWorkbookImpl(bootstrapInfo, this.embeddingId);
        let updatedCustomViews = [];
        if (this._customViewsTemp) {
            updatedCustomViews = this._workbookImpl.processCustomViews(api_internal_contract_js_1.NotificationId.CustomViewsLoaded, this._customViewsTemp);
        }
        this._viz.dispatchEvent(new CustomEvent(Contract.EmbeddingTableauEventType.FirstInteractive));
        if (this._customViewsTemp) {
            this.sendCustomViewEvents(Contract.EmbeddingTableauEventType.CustomViewLoaded, updatedCustomViews);
            this._customViewsTemp = null;
        }
    }
    handleVizSizeKnownEvent(model) {
        const sheetSize = api_shared_js_1.SheetUtils.getSheetSizeFromSizeConstraints(model.sheetSize);
        this._vizSize = new VizSize_1.VizSize(sheetSize, model.chromeHeight);
        const vizSizeEvent = new FirstVizSizeKnownEvent_1.FirstVizSizeKnownEvent(this._vizSize);
        this._viz.dispatchEvent(new CustomEvent(Contract.EmbeddingTableauEventType.FirstVizSizeKnown, { detail: vizSizeEvent }));
        if (this._viz.fixedSize) {
            return;
        }
        this.resize();
        this.addWindowResizeHandler();
    }
    resize() {
        const { height, width } = this.calculateLayoutSize();
        if (height === this._vizSize.chromeHeight) {
            // The chromeHeight is what is calculated for any UI contained within the iframe that
            // isn't the viz (e.g. toolbar, sheet tabs). If we calculate the height to be only a
            // big as a chromeHeight, then we are probably too early (e.g. mid-fullscreen change).
            // Related to defect 570417.
            return;
        }
        this._iframe.style.height = height + 'px';
        this._iframe.style.width = width + 'px';
    }
    calculateLayoutSize() {
        const availableSize = this._viz.parentElement ? HtmlElementHelpers_1.HtmlElementHelpers.getContentSize(this._viz.parentElement) : { height: 0, width: 0 };
        const { chromeHeight, sheetSize } = this._vizSize;
        let width = 0;
        let height = 0;
        const minSize = sheetSize.minSize || { height: 0, width: 0 };
        const maxSize = sheetSize.maxSize || { height: 0, width: 0 };
        // If it's an exact size, use it. The size of the container is disregarded.
        if (sheetSize.behavior === Contract.SheetSizeBehavior.Exactly) {
            width = maxSize.width;
            height = maxSize.height + chromeHeight;
        }
        else {
            let minWidth;
            let maxWidth;
            let minHeight;
            let maxHeight;
            switch (sheetSize.behavior) {
                case Contract.SheetSizeBehavior.Range:
                    // The iframe should obey the range. As the size of the container changes,
                    // the iframe changes size if it can remain within the range
                    minWidth = minSize.width;
                    maxWidth = maxSize.width;
                    minHeight = minSize.height + chromeHeight;
                    maxHeight = maxSize.height + chromeHeight;
                    width = Math.max(minWidth, Math.min(maxWidth, availableSize.width));
                    height = Math.max(minHeight, Math.min(maxHeight, availableSize.height));
                    break;
                case Contract.SheetSizeBehavior.AtLeast:
                    // The iframe should be no smaller than the minimum. As the size of the container changes,
                    // the iframe changes size if it can remain above the minimum size.
                    minWidth = minSize.width;
                    minHeight = minSize.height + chromeHeight;
                    width = Math.max(minWidth, availableSize.width);
                    height = Math.max(minHeight, availableSize.height);
                    break;
                case Contract.SheetSizeBehavior.AtMost:
                    // The iframe should be no larger than the maximum. As the size of the container changes,
                    // the iframe changes size if it can remain below the maximum size
                    maxWidth = maxSize.width;
                    maxHeight = maxSize.height + chromeHeight;
                    width = Math.min(maxWidth, availableSize.width);
                    height = Math.min(maxHeight, availableSize.height);
                    break;
                case Contract.SheetSizeBehavior.Automatic:
                    // the iframe should fill the containing element
                    width = availableSize.width;
                    height = Math.max(availableSize.height, chromeHeight);
                    break;
                default:
                    // We should never get here. The given size behavior is not one we know about. That would be a bug
                    throw new api_shared_js_1.TableauError(Contract.EmbeddingErrorCodes.InvalidSizeBehavior, 'Unknown SheetSizeBehavior for viz: ' + sheetSize.behavior);
            }
        }
        return { height, width };
    }
    removeWindowResizeHandler() {
        if (!this._windowResizeHandler) {
            return;
        }
        window.removeEventListener(this._resizeEventType, this._windowResizeHandler);
    }
    addWindowResizeHandler() {
        if (this._windowResizeHandler) {
            return;
        }
        this._windowResizeHandler = this.resize.bind(this);
        window.addEventListener(this._resizeEventType, this._windowResizeHandler);
    }
    handleToolbarStateEvent(model) {
        const toolbarStateChangedEvent = new ToolbarStateChangedEvent_1.ToolbarStateChangedEvent(model.toolbarState.canRedo, model.toolbarState.canUndo);
        this._viz.dispatchEvent(new CustomEvent(Contract.EmbeddingTableauEventType.ToolbarStateChanged, { detail: toolbarStateChangedEvent }));
    }
    handleTabSwitch(bootstrapInfo) {
        // If we didn't receive an interactive event that initializes the workbook, then ignore the tabswitch event
        if (!this._workbookImpl) {
            return;
        }
        if (!bootstrapInfo.oldSheetName) {
            return;
        }
        // Update the iframe title again when the active sheet has changed
        this.updateIframeTitle(bootstrapInfo);
        const pendingTabSwitchPromise = this._workbookImpl.pendingTabSwitchPromise;
        this._workbookImpl.updateExistingActiveSheetReferences(bootstrapInfo.currWorksheetName);
        this._workbookImpl = new EmbeddingWorkbookImpl_1.EmbeddingWorkbookImpl(bootstrapInfo, this.embeddingId);
        if (pendingTabSwitchPromise) {
            pendingTabSwitchPromise.resolve(this._workbookImpl);
        }
        const tabSwitchedEvent = new TabSwitchedEvent_1.TabSwitchedEvent(bootstrapInfo.oldSheetName, bootstrapInfo.currWorksheetName);
        this._viz.dispatchEvent(new CustomEvent(Contract.EmbeddingTableauEventType.TabSwitched, { detail: tabSwitchedEvent }));
    }
    handleCustomViews(customViewsInfo) {
        // If workbook is not initialized, temporarily store the custom views info in VizImpl
        if (!this._workbookImpl) {
            this._customViewsTemp = customViewsInfo;
        }
        else {
            const updatedCustomViews = this._workbookImpl.processCustomViews(api_internal_contract_js_1.NotificationId.CustomViewsLoaded, customViewsInfo);
            const pendingShowCustomViewPromise = this._workbookImpl.pendingShowCustomViewPromise;
            if (pendingShowCustomViewPromise) {
                const currentCustomView = updatedCustomViews[0];
                // currentCustomView can be undefined which means there is no active custom view.
                // This can happen when requesting the original view, which inactivates any custom view.
                pendingShowCustomViewPromise.resolve(currentCustomView);
                this._workbookImpl.clearPendingShowCustomViewPromise();
            }
            this.sendCustomViewEvents(Contract.EmbeddingTableauEventType.CustomViewLoaded, updatedCustomViews);
        }
    }
    handleCustomViewRemoved(customViewsInfo) {
        const updatedCustomViews = this._workbookImpl.processCustomViews(api_internal_contract_js_1.NotificationId.CustomViewRemoved, customViewsInfo);
        this.sendCustomViewEvents(Contract.EmbeddingTableauEventType.CustomViewRemoved, updatedCustomViews);
    }
    handleCustomViewSaved(customViewsInfo) {
        const updatedCustomViews = this._workbookImpl.processCustomViews(api_internal_contract_js_1.NotificationId.CustomViewSaved, customViewsInfo);
        this.sendCustomViewEvents(Contract.EmbeddingTableauEventType.CustomViewSaved, updatedCustomViews);
    }
    handleCustomViewSetDefault(customViewsInfo) {
        const updatedCustomViews = this._workbookImpl.processCustomViews(api_internal_contract_js_1.NotificationId.CustomViewSetDefault, customViewsInfo);
        this.sendCustomViewEvents(Contract.EmbeddingTableauEventType.CustomViewSetDefault, updatedCustomViews);
    }
    sendCustomViewEvents(tableauEvent, updatedCustomViews) {
        // Send an event only if there's an updated custom view
        for (let customView of updatedCustomViews) {
            const customViewEvent = { customView: new CustomView_1.CustomView(customView, this._workbookImpl) };
            this._viz.dispatchEvent(new CustomEvent(tableauEvent, { detail: customViewEvent }));
        }
    }
}
exports.VizImpl = VizImpl;
//# sourceMappingURL=VizImpl.js.map